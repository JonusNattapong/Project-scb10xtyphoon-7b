{
  "instructions": [
    {
      "instruction": "วิเคราะห์โค้ดต่อไปนี้และแนะนำวิธีปรับปรุง",
      "input": "def calculate_total(items):\n    total = 0\n    for i in range(len(items)):\n        total = total + items[i]['price']\n    return total",
      "output": "โค้ดสามารถปรับปรุงได้ดังนี้:\n\n1. ใช้ list comprehension หรือ sum() แทน for loop:\n```python\ndef calculate_total(items):\n    return sum(item['price'] for item in items)\n```\n\n2. เพิ่มการตรวจสอบ input:\n```python\ndef calculate_total(items):\n    if not items:  # ตรวจสอบ list ว่างไหม\n        return 0\n    if not all('price' in item for item in items):  # ตรวจสอบว่ามี key 'price' ไหม\n        raise ValueError('All items must have price')\n    return sum(item['price'] for item in items)\n```\n\nการปรับปรุงนี้ทำให้:\n- โค้ดกระชับขึ้น\n- ปลอดภัยขึ้นด้วยการตรวจสอบ input\n- อ่านง่ายขึ้น\n- ประสิทธิภาพดีขึ้นเพราะใช้ built-in function"
    },
    {
      "instruction": "อธิบายการทำงานของ git rebase และข้อควรระวัง",
      "output": "Git Rebase คือการจัดเรียง commit ใหม่ โดยมีรายละเอียดดังนี้:\n\n1. หลักการทำงาน:\n- ย้าย commit จาก branch ปัจจุบันไปต่อท้าย branch เป้าหมาย\n- สร้าง commit ใหม่ที่มี content เหมือนเดิมแต่ hash ต่างกัน\n\n2. การใช้งาน:\n```bash\n# อยู่ที่ feature branch\ngit rebase main  # rebase กับ main branch\n```\n\n3. ข้อดี:\n- ประวัติ commit เป็นเส้นตรง สะอาด\n- ลดความซับซ้อนของ branch\n- ง่ายต่อการ review code\n\n4. ข้อควรระวัง:\n- ห้าม rebase branch ที่มีคนอื่นใช้งานอยู่\n- ควรใช้กับ local branch เท่านั้น\n- ระวัง conflict ที่อาจเกิดขึ้น\n- ควร backup branch ก่อนทำ rebase\n\n5. วิธีแก้ไขเมื่อเกิดปัญหา:\n```bash\ngit rebase --abort  # ยกเลิก rebase\n# หรือ\ngit reset --hard ORIG_HEAD  # ย้อนกลับไปก่อน rebase\n```"
    },
    {
      "instruction": "เขียน SQL query เพื่อวิเคราะห์ยอดขายรายเดือน",
      "input": "มีตาราง:\n- orders (id, user_id, total_amount, created_at)\n- users (id, name, email)\nต้องการ: ยอดขายรวมรายเดือนปี 2024 เรียงตามเดือน และแสดงการเติบโต (%) เทียบกับเดือนก่อน",
      "output": "```sql\nWITH monthly_sales AS (\n  SELECT \n    DATE_TRUNC('month', created_at) AS month,\n    SUM(total_amount) AS total_sales\n  FROM orders\n  WHERE EXTRACT(YEAR FROM created_at) = 2024\n  GROUP BY DATE_TRUNC('month', created_at)\n),\nsales_growth AS (\n  SELECT\n    month,\n    total_sales,\n    LAG(total_sales) OVER (ORDER BY month) AS prev_month_sales,\n    CASE \n      WHEN LAG(total_sales) OVER (ORDER BY month) IS NULL THEN NULL\n      ELSE ROUND(\n        (total_sales - LAG(total_sales) OVER (ORDER BY month)) * 100.0 / \n        LAG(total_sales) OVER (ORDER BY month),\n        2\n      )\n    END AS growth_percentage\n  FROM monthly_sales\n)\nSELECT\n  TO_CHAR(month, 'Month YYYY') AS month,\n  total_sales,\n  COALESCE(growth_percentage, 0) || '%' AS growth\nFROM sales_growth\nORDER BY month;\n```\n\nคำอธิบาย Query:\n1. ใช้ CTE (WITH) เพื่อแบ่ง logic ให้อ่านง่าย\n2. DATE_TRUNC จัดกลุ่มตามเดือน\n3. LAG เปรียบเทียบกับเดือนก่อน\n4. COALESCE แปลง NULL เป็น 0%\n5. TO_CHAR จัดรูปแบบวันที่ให้สวยงาม\n\nผลลัพธ์จะแสดง:\n- เดือนและปี\n- ยอดขายรวม\n- เปอร์เซ็นต์การเติบโต"
    },
    {
      "instruction": "อธิบายวิธีการทำ Dependency Injection ใน TypeScript",
      "output": "Dependency Injection (DI) ใน TypeScript มีหลักการดังนี้:\n\n1. Interface Definition:\n```typescript\ninterface ILogger {\n  log(message: string): void;\n}\n\ninterface IUserService {\n  getUserById(id: string): Promise<User>;\n}\n```\n\n2. Concrete Implementation:\n```typescript\nclass ConsoleLogger implements ILogger {\n  log(message: string): void {\n    console.log(`[${new Date().toISOString()}] ${message}`);\n  }\n}\n\nclass UserService implements IUserService {\n  constructor(private logger: ILogger) {}\n\n  async getUserById(id: string): Promise<User> {\n    this.logger.log(`Fetching user ${id}`);\n    // ... fetch user logic\n  }\n}\n```\n\n3. DI Container Setup:\n```typescript\nclass Container {\n  private services = new Map();\n\n  register<T>(token: string, instance: T): void {\n    this.services.set(token, instance);\n  }\n\n  resolve<T>(token: string): T {\n    return this.services.get(token);\n  }\n}\n```\n\n4. Usage Example:\n```typescript\nconst container = new Container();\n\n// Register dependencies\ncontainer.register('logger', new ConsoleLogger());\ncontainer.register('userService', new UserService(container.resolve('logger')));\n\n// Use in application\nconst userService = container.resolve<IUserService>('userService');\nuserService.getUserById('123');\n```\n\nข้อดีของ DI:\n1. แยกการทำงานชัดเจน (Separation of Concerns)\n2. ทดสอบง่าย (Testability)\n3. ยืดหยุ่นในการเปลี่ยน implementation\n4. ลดการ coupling ระหว่าง component"
    },
    {
      "instruction": "สร้าง Regular Expression สำหรับตรวจสอบเบอร์โทรศัพท์มือถือไทย",
      "input": "รูปแบบที่ต้องการ:\n- ขึ้นต้นด้วย 06, 08, 09\n- มีตัวเลข 10 หลัก\n- อาจมีเครื่องหมายขีด (-) คั่นหรือไม่ก็ได้\n- อาจมีวงเล็บหรือไม่ก็ได้",
      "output": "Regular Expression:\n```typescript\nconst mobileRegex = /^(?:\\+66|0)(?:6|8|9)\\d{8}$|^(?:\\+66|0)(?:6|8|9)(?:\\d{1}-?\\d{3}-?\\d{4}|\\d{2}-?\\d{3}-?\\d{3})$/;\n```\n\nคำอธิบาย Pattern:\n1. `^` - จุดเริ่มต้น string\n2. `(?:\\+66|0)` - ขึ้นต้นด้วย +66 หรือ 0\n3. `(?:6|8|9)` - ตามด้วย 6, 8, หรือ 9\n4. `\\d{8}` - ตามด้วยตัวเลข 8 ตัว (กรณีไม่มีขีด)\n5. `|` - หรือ\n6. รูปแบบที่มีขีด:\n   - `\\d{1}-?\\d{3}-?\\d{4}` - x-xxx-xxxx\n   - `\\d{2}-?\\d{3}-?\\d{3}` - xx-xxx-xxx\n7. `$` - จุดสิ้นสุด string\n\nตัวอย่างการใช้งาน:\n```typescript\nfunction validateTHMobile(phone: string): boolean {\n  return mobileRegex.test(phone);\n}\n\n// ตัวอย่างที่ถูกต้อง\nconsole.log(validateTHMobile('0891234567'));     // true\nconsole.log(validateTHMobile('089-123-4567'));   // true\nconsole.log(validateTHMobile('0891-23-4567'));   // true\nconsole.log(validateTHMobile('+66891234567'));   // true\n\n// ตัวอย่างที่ไม่ถูกต้อง\nconsole.log(validateTHMobile('1891234567'));     // false\nconsole.log(validateTHMobile('089123456'));      // false\nconsole.log(validateTHMobile('089-123-456'));    // false\n```"
    }
  ]
}
